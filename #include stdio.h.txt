#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <dirent.h>

#define MAX_FILENAME_LENGTH 256
#define MAX_COMMENT_LENGTH 256
#define MAX_LEVELS 256

typedef struct {
    int width;
    int height;
    int maxval;
    unsigned char** data;
} PGMImage;

PGMImage* readPGM(const char* filename);
PGMImage* smoothImage(const PGMImage* input, int filterSize);
void quantizeImage(PGMImage* image, int levels);
int** calculateSCM(const PGMImage* image1, const PGMImage* image2);
int* vectorizeSCM(const int** scm, int width, int height);
void writeFeaturesToFile(const char* filename, const int* features, int numFeatures, int label, int levels);

// Função para ler uma imagem PGM a partir de um arquivo
PGMImage* readPGM(const char* filename) {
    FILE* file = fopen(filename, "rb");
    if (!file) {
        perror("Erro ao abrir o arquivo");
        exit(EXIT_FAILURE);
    }

    PGMImage* image = (PGMImage*)malloc(sizeof(PGMImage));
  PGMImage* readPGM(const char* filename) {
      FILE* file = fopen(filename, "rb");
      if (!file) {
          perror("Erro ao abrir o arquivo");
          exit(EXIT_FAILURE);
      }

      PGMImage* image = (PGMImage*)malloc(sizeof(PGMImage));
      if (!image) {
          perror("Erro de alocação de memória para a estrutura da imagem");
          exit(EXIT_FAILURE);
      }

      // Leitura do cabeçalho PGM
      char magic[3];
      if (fscanf(file, "%2s", magic) != 1 || strcmp(magic, "P5") != 0) {
          fprintf(stderr, "Formato de arquivo PGM inválido\n");
          exit(EXIT_FAILURE);
      }

      // Leitura do comentário (se houver)
      char comment[MAX_COMMENT_LENGTH];
      if (fscanf(file, "#%255[^\n]%*c", comment) == 1) {
          // O comentário foi lido, você pode fazer algo com ele se necessário
      }

      // Leitura da largura, altura e valor máximo
      if (fscanf(file, "%d %d %d", &image->width, &image->height, &image->maxval) != 3) {
          fprintf(stderr, "Erro ao ler largura, altura ou valor máximo\n");
          exit(EXIT_FAILURE);
      }

      // Alocação de memória para os dados da imagem
      image->data = (unsigned char**)malloc(image->height * sizeof(unsigned char*));
      if (!image->data) {
          perror("Erro de alocação de memória para os dados da imagem");
          exit(EXIT_FAILURE);
      }

      for (int i = 0; i < image->height; ++i) {
          image->data[i] = (unsigned char*)malloc(image->width * sizeof(unsigned char));
          if (!image->data[i]) {
              perror("Erro de alocação de memória para os dados da imagem");
              exit(EXIT_FAILURE);
          }
      }

      // Leitura dos dados da imagem
      for (int i = 0; i < image->height; ++i) {
          if (fread(image->data[i], sizeof(unsigned char), image->width, file) != image->width) {
              fprintf(stderr, "Erro ao ler dados da imagem\n");
              exit(EXIT_FAILURE);
          }
      }

      fclose(file);
      return image;
  }
  
    // Alocação de memória para os dados da imagem
    image->data = (unsigned char**)malloc(image->height * sizeof(unsigned char*));
    for (int i = 0; i < image->height; ++i) {
        image->data[i] = (unsigned char*)malloc(image->width * sizeof(unsigned char));
    }
  PGMImage* readPGM(const char* filename) {
      FILE* file = fopen(filename, "rb");
      if (!file) {
          perror("Erro ao abrir o arquivo");
          exit(EXIT_FAILURE);
      }

      PGMImage* image = (PGMImage*)malloc(sizeof(PGMImage));
      if (!image) {
          perror("Erro de alocação de memória para a estrutura da imagem");
          exit(EXIT_FAILURE);
      }

      // Leitura do cabeçalho PGM
      char magic[3];
      if (fscanf(file, "%2s", magic) != 1 || strcmp(magic, "P5") != 0) {
          fprintf(stderr, "Formato de arquivo PGM inválido\n");
          exit(EXIT_FAILURE);
      }

      // Leitura do comentário (se houver)
      char comment[MAX_COMMENT_LENGTH];
      if (fscanf(file, "#%255[^\n]%*c", comment) == 1) {
          // O comentário foi lido, você pode fazer algo com ele se necessário
      }

      // Leitura da largura, altura e valor máximo
      if (fscanf(file, "%d %d %d", &image->width, &image->height, &image->maxval) != 3) {
          fprintf(stderr, "Erro ao ler largura, altura ou valor máximo\n");
          exit(EXIT_FAILURE);
      }

      // Alocação de memória para os dados da imagem
      image->data = (unsigned char**)malloc(image->height * sizeof(unsigned char*));
      if (!image->data) {
          perror("Erro de alocação de memória para os dados da imagem");
          exit(EXIT_FAILURE);
      }

      for (int i = 0; i < image->height; ++i) {
          image->data[i] = (unsigned char*)malloc(image->width * sizeof(unsigned char));
          if (!image->data[i]) {
              perror("Erro de alocação de memória para os dados da imagem");
              exit(EXIT_FAILURE);
          }
      }

      // Leitura dos dados da imagem
      for (int i = 0; i < image->height; ++i) {
          if (fread(image->data[i], sizeof(unsigned char), image->width, file) != image->width) {
              fprintf(stderr, "Erro ao ler dados da imagem\n");
              exit(EXIT_FAILURE);
          }
      }

      fclose(file);
      return image;
  }


    fclose(file);
    return image;
}

// Função para suavizar uma imagem PGM com filtro da média
PGMImage* smoothImage(const PGMImage* input, int filterSize) {
  PGMImage* smoothImage(const PGMImage* input, int filterSize) {
      PGMImage* smoothedImage = (PGMImage*)malloc(sizeof(PGMImage));
      if (!smoothedImage) {
          perror("Erro de alocação de memória para a imagem suavizada");
          exit(EXIT_FAILURE);
      }

      smoothedImage->width = input->width;
      smoothedImage->height = input->height;
      smoothedImage->maxval = input->maxval;

      // Alocação de memória para os dados da imagem suavizada
      smoothedImage->data = (unsigned char**)malloc(smoothedImage->height * sizeof(unsigned char*));
      if (!smoothedImage->data) {
          perror("Erro de alocação de memória para os dados da imagem suavizada");
          exit(EXIT_FAILURE);
      }

      // Suavização dos dados da imagem
      for (int i = 0; i < smoothedImage->height; ++i) {
          smoothedImage->data[i] = (unsigned char*)malloc(smoothedImage->width * sizeof(unsigned char));
          if (!smoothedImage->data[i]) {
              perror("Erro de alocação de memória para os dados da imagem suavizada");
              exit(EXIT_FAILURE);
          }

          for (int j = 0; j < smoothedImage->width; ++j) {
              // Suavização com filtro de média
              int sum = 0;
              int count = 0;

              for (int ni = -filterSize / 2; ni <= filterSize / 2; ++ni) {
                  for (int nj = -filterSize / 2; nj <= filterSize / 2; ++nj) {
                      int row = i + ni;
                      int col = j + nj;

                      // Verificar limites da imagem
                      if (row >= 0 && row < input->height && col >= 0 && col < input->width) {
                          sum += input->data[row][col];
                          ++count;
                      }
                  }
              }

              smoothedImage->data[i][j] = (unsigned char)(sum / count);
          }
      }

      return smoothedImage;
  }

}

// Função para quantizar uma imagem PGM
void quantizeImage(PGMImage* image, int levels) {
  void quantizeImage(PGMImage* image, int levels) {
      if (levels <= 0 || levels > 256) {
          fprintf(stderr, "Número inválido de níveis de quantização\n");
          exit(EXIT_FAILURE);
      }

      int step = 256 / levels;

      for (int i = 0; i < image->height; ++i) {
          for (int j = 0; j < image->width; ++j) {
              int newValue = (image->data[i][j] / step) * step;
              image->data[i][j] = (unsigned char)newValue;
          }
      }
  }


// Função para calcular a matriz SCM entre duas imagens PGM
int** calculateSCM(const PGMImage* image1, const PGMImage* image2) {
  int** calculateSCM(const PGMImage* image1, const PGMImage* image2) {
      if (image1->width != image2->width || image1->height != image2->height) {
          fprintf(stderr, "As dimensões das imagens não são iguais\n");
          exit(EXIT_FAILURE);
      }

      int** scm = (int**)malloc(256 * sizeof(int*));
      if (!scm) {
          perror("Erro de alocação de memória para a matriz SCM");
          exit(EXIT_FAILURE);
      }

      for (int i = 0; i < 256; ++i) {
          scm[i] = (int*)calloc(256, sizeof(int));
          if (!scm[i]) {
              perror("Erro de alocação de memória para a matriz SCM");
              exit(EXIT_FAILURE);
          }
      }

      for (int i = 0; i < image1->height; ++i) {
          for (int j = 0; j < image1->width; ++j) {
              // Adicione o valor 1 à posição correspondente na matriz SCM
              // para indicar a coocorrência das intensidades adjacentes
              if (j + 1 < image1->width) {
                  scm[image1->data[i][j]][image1->data[i][j + 1]]++;
                  scm[image1->data[i][j + 1]][image1->data[i][j]]++;
              }

              if (i + 1 < image1->height) {
                  scm[image1->data[i][j]][image1->data[i + 1][j]]++;
                  scm[image1->data[i + 1][j]][image1->data[i][j]]++;
              }

              if (i + 1 < image1->height && j + 1 < image1->width) {
                  scm[image1->data[i][j]][image1->data[i + 1][j + 1]]++;
                  scm[image1->data[i + 1][j + 1]][image1->data[i][j]]++;
              }
          }
      }

      return scm;
  }

}

// Função para vetorizar a matriz SCM
int* vectorizeSCM(const int** scm, int width, int height) {
  int* vectorizeSCM(const int** scm, int width, int height) {
      int* vectorizedSCM = (int*)malloc(width * height * sizeof(int));
      if (!vectorizedSCM) {
          perror("Erro de alocação de memória para o vetor da matriz SCM");
          exit(EXIT_FAILURE);
      }

      int index = 0;

      for (int i = 0; i < height; ++i) {
          for (int j = 0; j < width; ++j) {
              vectorizedSCM[index++] = scm[i][j];
          }
      }

      return vectorizedSCM;
  }

}

// Função para gravar os valores vetorizados em um arquivo
void writeFeaturesToFile(const char* filename, const int* features, int numFeatures, int label, int levels) {
  void writeFeaturesToFile(const char* filename, const int* features, int numFeatures, int label, int levels) {
      FILE* file = fopen(filename, "a");  // Modo "a" para adicionar ao arquivo existente ou criar se não existir
      if (!file) {
          perror("Erro ao abrir o arquivo para gravação");
          exit(EXIT_FAILURE);
      }

      // Gravação dos valores vetorizados no arquivo
      for (int i = 0; i < numFeatures; ++i) {
          fprintf(file, "%d ", features[i]);
      }

      // Inclusão do rótulo da imagem
      fprintf(file, "%d\n", label);

      // Fechamento do arquivo
      fclose(file);
  }

}

int main(int argc, char* argv[]) {
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <dirent.h>

  // Definições de funções e estruturas
  // ...

  int main(int argc, char* argv[]) {
      if (argc != 4) {
          fprintf(stderr, "Uso: %s <diretorio_imagens> <diretorio_saida> <num_niveis_quantizacao>\n", argv[0]);
          exit(EXIT_FAILURE);
      }

      char* inputDirectory = argv[1];
      char* outputDirectory = argv[2];
      int levels = atoi(argv[3]);

      DIR* dir = opendir(inputDirectory);
      if (!dir) {
          perror("Erro ao abrir o diretório de entrada");
          exit(EXIT_FAILURE);
      }

      struct dirent* entry;
      while ((entry = readdir(dir)) != NULL) {
          if (entry->d_type == DT_REG) {  // Verifica se é um arquivo regular
              char filePath[256];
              sprintf(filePath, "%s/%s", inputDirectory, entry->d_name);

              // Leitura da imagem original
              PGMImage* originalImage = readPGM(filePath);

              // Suavização da imagem
              PGMImage* smoothedImage = smoothImage(originalImage, 3);  // Exemplo: filtro 3x3

              // Quantização da imagem suavizada
              quantizeImage(smoothedImage, levels);

              // Cálculo da matriz SCM
              int** scm = calculateSCM(originalImage, smoothedImage);

              // Vetorização da matriz SCM
              int* vectorizedSCM = vectorizeSCM(scm, originalImage->width, originalImage->height);

              // Gravação dos resultados em um arquivo
              char outputFileName[256];
              sprintf(outputFileName, "%s/features_%d.txt", outputDirectory, levels);
              writeFeaturesToFile(outputFileName, vectorizedSCM, originalImage->width * originalImage->height, 0, levels);

              // Liberação de memória
              // ...

              // Fechamento do arquivo
              fclose(file);
          }
      }

      closedir(dir);

      return 0;
  }


    return 0;
}
